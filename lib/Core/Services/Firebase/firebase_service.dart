import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:firebase_core/firebase_core.dart';
import 'package:google_sign_in/google_sign_in.dart';

import '../../../Config/env_config.dart';
import '../../Utils/Enums/collection_key.dart';
import 'Logic/firebase_service_error_handler.dart';
import 'Logic/firebase_service_logic.dart';
import 'response_model.dart';

class FirebaseServices {
  FirebaseServices._();

  static final FirebaseServices _instance = FirebaseServices._();
  static FirebaseServices get instance => _instance;

  final GoogleSignIn _googleSignIn = GoogleSignIn.instance;

  FirebaseAuth? _auth;
  FirebaseFirestore? firestore;
  FirebaseServiceLogic? _logic;
  bool _isInitialized = false;

  Future<void> initialize() async {
    if (_isInitialized) return;

    await Firebase.initializeApp();
    _auth = FirebaseAuth.instance;
    firestore = FirebaseFirestore.instance;
    _logic = FirebaseServiceLogic(firestore!);
    await _configureLocalCache();

    _isInitialized = true;
  }

  Future<void> _configureLocalCache() async {
    final db = firestore;
    if (db == null) return;

    try {
      db.settings = const Settings(
        persistenceEnabled: true,
        cacheSizeBytes: Settings.CACHE_SIZE_UNLIMITED,
        
      );
    } catch (_) {
      // Ignore if settings are already applied.
    }
  }

  FirebaseServiceLogic get _db {
    final logic = _logic;
    if (logic != null) return logic;

    final db = firestore;
    if (db == null) {
      throw StateError(
        'FirebaseServices is not initialized. Call initialize() first.',
      );
    }

    _logic = FirebaseServiceLogic(db);
    return _logic!;
  }

  Future<ResponseModel> loginAccount(String email, String password) async {
    try {
      final userCredential = await _auth!.signInWithEmailAndPassword(
        email: email,
        password: password,
      );
      return ResponseModel.success(
        message: 'Login successfully',
        data: userCredential.user?.uid,
      );
    } on FirebaseAuthException catch (error) {
      return FirebaseServiceErrorHandler.authError(
        'Firebase Authentication Error during sign in',
        error,
      );
    } catch (error) {
      return FirebaseServiceErrorHandler.operationError(
        'An unexpected error occurred during login',
        error,
      );
    }
  }

  Future<ResponseModel> createAccount(
    Map<String, dynamic> account,
    String id,
  ) async {
    try {
      final response = await addData(CollectionKey.users.key, id, account);
      return response.copyWith(message: 'Account created successfully');
    } on FirebaseAuthException catch (error) {
      return FirebaseServiceErrorHandler.authError(
        'Firebase Authentication Error during account creation',
        error,
      );
    } catch (error) {
      return FirebaseServiceErrorHandler.operationError(
        'An unexpected error occurred during account creation',
        error,
      );
    }
  }

  Future<GoogleSignInAccount> google() async {
    final webClientId = EnvConfig.googleWebClientId;
    await _googleSignIn.initialize(
      clientId: webClientId.isEmpty ? null : webClientId,
    );

    final googleAccount = await _googleSignIn.authenticate();
    final googleAuth = googleAccount.authentication;
    final credential = GoogleAuthProvider.credential(
      idToken: googleAuth.idToken,
    );

    await FirebaseAuth.instance.signInWithCredential(credential);
    return googleAccount;
  }

  Future<void> logOut() async {
    await _auth?.signOut();
    await _googleSignIn.signOut();
    _isInitialized = false;
    _logic = null;
  }

  Future<ResponseModel> checkIsExists(
    String field,
    String collectionName,
    String search,
  ) async {
    try {
      final querySnapshot = await firestore!
          .collection(collectionName)
          .where(field, isEqualTo: search)
          .limit(1)
          .get();

      if (querySnapshot.docs.isEmpty) {
        return ResponseModel.error(message: 'does not exist');
      }

      return ResponseModel.success(
        message: 'exists',
        data: querySnapshot.docs.first.id,
      );
    } catch (error) {
      return FirebaseServiceErrorHandler.operationError(
        'Error checking document existence',
        error,
      );
    }
  }

  Future<ResponseModel> addData(
    String mainCollectionName,
    String mainDocumentId,
    Map<String, dynamic> data, {
    List<String>? subCollections,
    List<String>? subIds,
  }) async {
    try {
      final docRef = _db.resolveDocumentReference(
        mainCollectionName: mainCollectionName,
        mainDocumentId: mainDocumentId,
        subCollections: subCollections,
        subIds: subIds,
        allowAutoGeneratedSubIds: true,
      );

      await docRef.set(data);
      return ResponseModel.success(
        message: 'Data added successfully',
        data: mainDocumentId,
      );
    } catch (error) {
      return FirebaseServiceErrorHandler.operationError(
        'Error adding data',
        error,
      );
    }
  }

  Future<ResponseModel> removeData(
    String mainCollectionName,
    String documentId, {
    List<String>? subCollections,
    List<String>? subIds,
  }) async {
    try {
      final docRef = _db.resolveDocumentReference(
        mainCollectionName: mainCollectionName,
        mainDocumentId: documentId,
        subCollections: subCollections,
        subIds: subIds,
      );

      await docRef.delete();
      return ResponseModel.success(message: 'Data removed successfully');
    } catch (error) {
      return FirebaseServiceErrorHandler.operationError(
        'Error removing data',
        error,
      );
    }
  }

  Future<ResponseModel> updateData(
    String mainCollectionName,
    String documentId,
    Map<String, dynamic> data, {
    List<String>? subCollections,
    List<String>? subIds,
  }) async {
    try {
      final docRef = _db.resolveDocumentReference(
        mainCollectionName: mainCollectionName,
        mainDocumentId: documentId,
        subCollections: subCollections,
        subIds: subIds,
      );

      await docRef.update(data);
      return ResponseModel.success(message: 'Updated successfully');
    } catch (error) {
      return FirebaseServiceErrorHandler.operationError(
        'Error updating data',
        error,
      );
    }
  }

  Future<ResponseModel> getData(
    String documentId,
    String mainCollectionName, {
    List<String>? subCollections,
    List<String>? subIds,
  }) async {
    try {
      final docRef = _db.resolveDocumentReference(
        mainCollectionName: mainCollectionName,
        mainDocumentId: documentId,
        subCollections: subCollections,
        subIds: subIds,
      );

      final snapshot = await docRef.get();
      if (!snapshot.exists) {
        return ResponseModel.error(message: 'No data found', data: null);
      }

      return ResponseModel.success(
        message: 'Data retrieved successfully',
        data: snapshot.data(),
      );
    } catch (error) {
      return FirebaseServiceErrorHandler.operationError(
        'Error getting data',
        error,
      );
    }
  }

  Future<ResponseModel> getAllData(
    String mainCollectionName,
    String documentId, {
    List<String>? subCollections,
    List<String>? subIds,
  }) async {
    try {
      final collectionRef = _db.resolveCollectionForGetAllData(
        mainCollectionName: mainCollectionName,
        mainDocumentId: documentId,
        subCollections: subCollections,
        subIds: subIds,
      );

      final querySnapshot = await collectionRef.get();
      final results = querySnapshot.docs.map((doc) => doc.data()).toList();

      return ResponseModel.success(
        message: 'Data retrieved successfully',
        data: results,
      );
    } catch (error) {
      return FirebaseServiceErrorHandler.operationError(
        'Error getting data',
        error,
      );
    }
  }

  Future<ResponseModel> findDocsByField(
    String collectionName,
    String field, {
    String nameField = 'id',
    int? limit,
    List<String>? subCollections,
    List<String>? subIds,
  }) async {
    try {
      final collectionRef = _db.resolveCollectionForQuery(
        collectionName: collectionName,
        subCollections: subCollections,
        subIds: subIds,
      );

      Query<Map<String, dynamic>> query =
          collectionRef.where(nameField, isEqualTo: field);

      if (limit != null && limit > 0) {
        query = query.limit(limit);
      }

      final snapshot = await query.get();
      final results = snapshot.docs.map(_withDocumentId).toList();

      return ResponseModel.success(
        message: results.isEmpty
            ? 'No documents found for $field in $collectionName'
            : 'Found ${results.length} documents',
        data: results,
      );
    } catch (error) {
      return FirebaseServiceErrorHandler.operationError(
        'Error querying $collectionName by $nameField',
        error,
      );
    }
  }

  Future<ResponseModel> findDocsInList(
    String collectionName,
    String field, {
    String nameField = '',
    int? limit,
    List<String>? subCollections,
    List<String>? subIds,
  }) async {
    try {
      final collectionRef = _db.resolveCollectionForQuery(
        collectionName: collectionName,
        subCollections: subCollections,
        subIds: subIds,
      );

      Query<Map<String, dynamic>> query =
          collectionRef.where(nameField, arrayContains: field);

      if (limit != null && limit > 0) {
        query = query.limit(limit);
      }

      final snapshot = await query.get();
      final results = snapshot.docs.map(_withDocumentId).toList();

      return ResponseModel.success(
        message: results.isEmpty
            ? 'No documents found for $field in $collectionName'
            : 'Found ${results.length} documents',
        data: results,
      );
    } catch (error) {
      return FirebaseServiceErrorHandler.operationError(
        'Error querying $collectionName by $nameField',
        error,
      );
    }
  }

  Stream<ResponseModel> findDocsInListStream(
    String collectionName,
    String field, {
    String nameField = '',
    int? limit,
    List<String>? subCollections,
    List<String>? subIds,
  }) {
    try {
      final collectionRef = _db.resolveCollectionForQuery(
        collectionName: collectionName,
        subCollections: subCollections,
        subIds: subIds,
      );

      Query<Map<String, dynamic>> query =
          collectionRef.where(nameField, isEqualTo: field);

      if (limit != null && limit > 0) {
        query = query.limit(limit);
      }

      return query.snapshots().map((snapshot) {
        final results = snapshot.docs.map(_withDocumentId).toList();
        return ResponseModel.success(
          message: results.isEmpty
              ? 'No documents found for $field in $collectionName'
              : 'Found ${results.length} documents',
          data: results,
        );
      }).handleError((error) {
        return FirebaseServiceErrorHandler.operationError(
          'Error streaming $collectionName by $nameField',
          error,
        );
      });
    } catch (error) {
      return Stream.value(
        FirebaseServiceErrorHandler.operationError(
          'Error setting up stream for $collectionName by $nameField',
          error,
        ),
      );
    }
  }

  Map<String, dynamic> _withDocumentId(
    QueryDocumentSnapshot<Map<String, dynamic>> doc,
  ) {
    final data = Map<String, dynamic>.from(doc.data());
    data['id'] = doc.id;
    return data;
  }

  Future<ResponseModel> sendEmailVerification() async {
    try {
      final user = _auth!.currentUser;
      if (user == null) {
        return ResponseModel.error(message: 'No user signed in.');
      }

      if (user.emailVerified) {
        return ResponseModel.success(message: 'Email is already verified.');
      }

      await user.sendEmailVerification();
      return ResponseModel.success(message: 'Verification email sent.');
    } on FirebaseAuthException catch (error) {
      return FirebaseServiceErrorHandler.authError(
        'Error sending verification email',
        error,
      );
    } catch (error) {
      return FirebaseServiceErrorHandler.operationError(
        'Unexpected error sending verification email',
        error,
      );
    }
  }

  Future<ResponseModel> isEmailVerified() async {
    final user = _auth!.currentUser;
    if (user == null) {
      return ResponseModel.error(
        message: 'No user signed in.',
        data: false,
      );
    }

    await user.reload();
    return ResponseModel.success(
      message: 'Checked email verification status.',
      data: user.emailVerified,
    );
  }

  Future<ResponseModel> sendPhoneVerification(String phoneNumber) async {
    return ResponseModel.success(
      message: 'Phone verification initiated. Implement UI flow for OTP.',
    );
  }

  Future<ResponseModel> addOrUpdateNotification(
    String userId,
    Map<String, dynamic> notificationData,
    String notificationKey,
  ) async {
    try {
      final docRef = firestore!.collection(CollectionKey.users.key).doc(userId);
      final docSnapshot = await docRef.get();

      if (!docSnapshot.exists) {
        return ResponseModel.error(message: 'User document not found');
      }

      final notificationId = notificationData['id_notification'];
      final data = docSnapshot.data();
      final notifications = List<dynamic>.from(data?[notificationKey] ?? []);

      notifications.removeWhere((item) => item['id_notification'] == notificationId);
      notifications.add(notificationData);

      await docRef.update({notificationKey: notifications});
      return ResponseModel.success(
        message: 'Notification updated successfully',
        data: notificationId,
      );
    } catch (error) {
      return FirebaseServiceErrorHandler.operationError(
        'Error updating notification',
        error,
      );
    }
  }

  Future<ResponseModel> addOrUpdateNotifications(
    String userId,
    List<Map<String, dynamic>> notificationsData,
    String notificationKey,
  ) async {
    try {
      final docRef = firestore!.collection(CollectionKey.users.key).doc(userId);
      final docSnapshot = await docRef.get();

      if (!docSnapshot.exists) {
        return ResponseModel.error(message: 'User document not found');
      }

      final data = docSnapshot.data();
      final notifications = List<dynamic>.from(data?[notificationKey] ?? []);

      for (final notificationData in notificationsData) {
        final notificationId = notificationData['id_notification'];
        notifications.removeWhere((item) => item['id_notification'] == notificationId);
        notifications.add(notificationData);
      }

      await docRef.update({notificationKey: notifications});
      return ResponseModel.success(
        message: 'Notifications updated successfully',
        data: notificationsData.length,
      );
    } catch (error) {
      return FirebaseServiceErrorHandler.operationError(
        'Error updating notifications',
        error,
      );
    }
  }
}
